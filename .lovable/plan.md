

## Fix: Manually Parse Hash Fragment Tokens on Published URL

### Root Cause (Now Confirmed)
After Google OAuth on the published URL, Supabase redirects back to:
```
https://maitreya-il.lovable.app/admin#access_token=...&refresh_token=...&expires_in=3600&token_type=bearer
```

The tokens are in the **URL hash fragment** (`#`). Supabase's built-in `detectSessionInUrl` should auto-detect these, but it fails silently because the `state` parameter was generated by Lovable's auth bridge, not by Supabase's own OAuth flow. The state validation mismatch causes Supabase to ignore the tokens entirely.

The `onAuthStateChange` then fires with `null`, the 1.5s grace period passes with no session arriving, and the login form appears -- even though valid tokens are sitting right there in the URL.

### Solution
Add explicit hash fragment parsing in the Admin page's auth `useEffect`. If `#access_token` is found in the URL, extract the tokens and manually call `supabase.auth.setSession()`.

### Technical Changes

**File: `src/pages/Admin.tsx`** -- Add hash fragment handling inside the existing `useEffect` (after setting up `onAuthStateChange`, before the safety timeout):

```typescript
useEffect(() => {
  let isMounted = true;
  let hasReceivedSession = false;

  const checkAdminRole = async (userId: string) => {
    // ... same as current
  };

  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    (event, session) => {
      if (!isMounted) return;
      const currentUser = session?.user ?? null;
      setUser(currentUser);

      if (currentUser) {
        hasReceivedSession = true;
        setTimeout(() => checkAdminRole(currentUser.id), 0);
      } else {
        setIsAdmin(false);
        setTimeout(() => {
          if (isMounted && !hasReceivedSession) {
            setLoading(false);
          }
        }, 1500);
      }
    }
  );

  // NEW: Handle OAuth tokens in URL hash fragment (published URL flow)
  const hash = window.location.hash;
  if (hash && hash.includes('access_token=')) {
    const params = new URLSearchParams(hash.substring(1));
    const accessToken = params.get('access_token');
    const refreshToken = params.get('refresh_token');

    if (accessToken && refreshToken) {
      // Clear the hash to prevent re-processing on refresh
      window.history.replaceState(null, '', window.location.pathname);

      supabase.auth.setSession({
        access_token: accessToken,
        refresh_token: refreshToken,
      }).catch((error) => {
        console.error('Failed to set session from URL tokens:', error);
        if (isMounted) setLoading(false);
      });
    }
  }

  // Safety timeout
  const timeout = setTimeout(() => {
    if (isMounted) setLoading(false);
  }, 8000);

  return () => {
    isMounted = false;
    clearTimeout(timeout);
    subscription.unsubscribe();
  };
}, []);
```

### How This Solves the Problem

1. On the published URL, after Google OAuth, the page loads with `#access_token=...` in the URL
2. The new code detects these tokens in the hash fragment
3. It calls `supabase.auth.setSession()` with the access and refresh tokens
4. This triggers `onAuthStateChange` with a valid session
5. `hasReceivedSession = true`, admin role is checked, dashboard appears
6. The hash is cleared from the URL so it looks clean

### Why the URL is Long and Cluttered
The long URL is normal -- it's Supabase's **implicit OAuth flow**. After Google authentication, Supabase appends the JWT access token (which contains encoded user data like email, name, avatar, etc.), a refresh token, expiry, and state parameter as hash fragments. This is standard OAuth 2.0 behavior. The `replaceState` call in the fix will clean it up immediately after processing.

### What Changes
- Only the `useEffect` in Admin.tsx (adding ~15 lines of hash parsing)
- Everything else stays the same

### What Stays the Same
- The `onAuthStateChange` listener (still handles preview environment and normal sessions)
- The 1.5s grace period (still needed for preview environment)
- Login form UI, admin dashboard, all handlers
- Google sign-in via `lovable.auth.signInWithOAuth`
